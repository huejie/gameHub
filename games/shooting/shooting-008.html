<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¦å…‹å¤§æˆ˜ - GameHub100</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Arial', sans-serif;
            background: #2d3436;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            color: white;
        }
        .header { padding: 15px; text-align: center; }
        h1 { font-size: 1.8rem; }
        .game-container { position: relative; }
        canvas { border: 3px solid #6c5ce7; border-radius: 10px; display: block; }
        .stats { display: flex; gap: 20px; margin: 10px 0; }
        .stat { text-align: center; }
        .stat-value { font-size: 1.5rem; font-weight: bold; color: #6c5ce7; }
        .controls { display: flex; gap: 10px; margin-top: 10px; }
        button {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            background: #6c5ce7;
            color: white;
            font-weight: bold;
        }
        button:hover { background: #a29bfe; }
        .back-link { position: fixed; top: 10px; left: 10px; color: #a29bfe; text-decoration: none; }
        .info { font-size: 0.85rem; opacity: 0.8; margin-top: 5px; }
        .game-over {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            padding: 30px; border-radius: 15px;
            text-align: center; display: none;
        }
        .game-over h2 { color: #e74c3c; }
    </style>
</head>
<body>
    <a href="../../index.html" class="back-link">â† è¿”å›</a>
    <div class="header">
        <h1>ğŸ–ï¸ å¦å…‹å¤§æˆ˜</h1>
        <p class="info">WASDç§»åŠ¨ï¼Œé¼ æ ‡ç„å‡†ï¼Œç‚¹å‡»å°„å‡»</p>
    </div>
    <div class="stats">
        <div class="stat"><div class="stat-value" id="score">0</div><div>å¾—åˆ†</div></div>
        <div class="stat"><div class="stat-value" id="health">100</div><div>è¡€é‡</div></div>
        <div class="stat"><div class="stat-value" id="enemies">0</div><div>å‡»æ€</div></div>
    </div>
    <div class="game-container">
        <canvas id="gameCanvas" width="500" height="400"></canvas>
        <div class="game-over" id="gameOver">
            <h2>æˆ˜æ–—ç»“æŸ</h2>
            <p>å‡»æ€: <span id="finalKills">0</span></p>
            <button onclick="restartGame()">é‡æ–°å¼€å§‹</button>
        </div>
    </div>
    <div class="controls">
        <button onclick="startGame()">å¼€å§‹æ¸¸æˆ</button>
        <button onclick="pauseGame()">æš‚åœ</button>
    </div>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        let player, enemies, bullets, walls, explosions;
        let score = 0, kills = 0;
        let gameRunning = false, gamePaused = false;
        let keys = {};
        let mouseX = 0, mouseY = 0;
        
        class Tank {
            constructor(x, y, isPlayer = false) {
                this.x = x; this.y = y;
                this.width = 30; this.height = 30;
                this.angle = isPlayer ? -Math.PI/2 : Math.PI/2;
                this.speed = isPlayer ? 3 : 1.5;
                this.isPlayer = isPlayer;
                this.health = isPlayer ? 100 : 30;
                this.lastShot = 0;
                this.fireRate = isPlayer ? 300 : 1500;
                this.color = isPlayer ? '#00b894' : '#d63031';
            }
            update() {
                if (this.isPlayer) {
                    let dx = 0, dy = 0;
                    if (keys['KeyW'] || keys['ArrowUp']) dy = -this.speed;
                    if (keys['KeyS'] || keys['ArrowDown']) dy = this.speed;
                    if (keys['KeyA'] || keys['ArrowLeft']) dx = -this.speed;
                    if (keys['KeyD'] || keys['ArrowRight']) dx = this.speed;
                    
                    const newX = this.x + dx;
                    const newY = this.y + dy;
                    
                    if (!this.checkWallCollision(newX, this.y)) this.x = newX;
                    if (!this.checkWallCollision(this.x, newY)) this.y = newY;
                    
                    this.x = Math.max(20, Math.min(canvas.width - 20, this.x));
                    this.y = Math.max(20, Math.min(canvas.height - 20, this.y));
                    
                    this.angle = Math.atan2(mouseY - this.y, mouseX - this.x);
                } else {
                    // AI: move toward player
                    if (player) {
                        const dx = player.x - this.x;
                        const dy = player.y - this.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        if (dist > 150) {
                            const newX = this.x + (dx/dist) * this.speed;
                            const newY = this.y + (dy/dist) * this.speed;
                            if (!this.checkWallCollision(newX, this.y)) this.x = newX;
                            if (!this.checkWallCollision(this.x, newY)) this.y = newY;
                        }
                        this.angle = Math.atan2(dy, dx);
                        if (dist < 300 && Date.now() - this.lastShot > this.fireRate) {
                            this.shoot();
                            this.lastShot = Date.now();
                        }
                    }
                }
            }
            checkWallCollision(x, y) {
                for (let wall of walls) {
                    if (x + 15 > wall.x && x - 15 < wall.x + wall.w &&
                        y + 15 > wall.y && y - 15 < wall.y + wall.h) {
                        return true;
                    }
                }
                return false;
            }
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                
                // Body
                ctx.fillStyle = this.color;
                ctx.fillRect(-15, -12, 30, 24);
                
                // Turret
                ctx.fillStyle = this.isPlayer ? '#00a884' : '#c0392b';
                ctx.beginPath();
                ctx.arc(0, 0, 10, 0, Math.PI * 2);
                ctx.fill();
                
                // Barrel
                ctx.fillStyle = '#2d3436';
                ctx.fillRect(5, -3, 20, 6);
                
                ctx.restore();
                
                // Health bar
                if (!this.isPlayer) {
                    ctx.fillStyle = '#e74c3c';
                    ctx.fillRect(this.x - 15, this.y - 25, 30, 4);
                    ctx.fillStyle = '#2ecc71';
                    ctx.fillRect(this.x - 15, this.y - 25, 30 * (this.health / 30), 4);
                }
            }
            shoot() {
                bullets.push(new Bullet(
                    this.x + Math.cos(this.angle) * 25,
                    this.y + Math.sin(this.angle) * 25,
                    this.angle,
                    this.isPlayer
                ));
                this.lastShot = Date.now();
            }
        }
        
        class Bullet {
            constructor(x, y, angle, isPlayer) {
                this.x = x; this.y = y;
                this.angle = angle;
                this.speed = 8;
                this.isPlayer = isPlayer;
                this.radius = 4;
            }
            update() {
                this.x += Math.cos(this.angle) * this.speed;
                this.y += Math.sin(this.angle) * this.speed;
            }
            draw() {
                ctx.fillStyle = this.isPlayer ? '#ffeaa7' : '#ff7675';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
            }
            checkWallHit() {
                for (let wall of walls) {
                    if (this.x > wall.x && this.x < wall.x + wall.w &&
                        this.y > wall.y && this.y < wall.y + wall.h) {
                        return true;
                    }
                }
                return false;
            }
        }
        
        class Explosion {
            constructor(x, y) {
                this.x = x; this.y = y;
                this.radius = 5;
                this.alpha = 1;
            }
            update() { this.radius += 3; this.alpha -= 0.05; }
            draw() {
                ctx.globalAlpha = this.alpha;
                ctx.fillStyle = '#f39c12';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
            isDone() { return this.alpha <= 0; }
        }
        
        function initWalls() {
            walls = [
                {x: 100, y: 80, w: 20, h: 100},
                {x: 200, y: 200, w: 100, h: 20},
                {x: 380, y: 100, w: 20, h: 100},
                {x: 300, y: 280, w: 80, h: 20},
                {x: 150, y: 300, w: 20, h: 80},
            ];
        }
        
        function spawnEnemy() {
            if (enemies.length < 3 + Math.floor(kills / 5)) {
                const side = Math.floor(Math.random() * 4);
                let x, y;
                switch(side) {
                    case 0: x = Math.random() * canvas.width; y = -30; break;
                    case 1: x = canvas.width + 30; y = Math.random() * canvas.height; break;
                    case 2: x = Math.random() * canvas.width; y = canvas.height + 30; break;
                    case 3: x = -30; y = Math.random() * canvas.height; break;
                }
                enemies.push(new Tank(x, y, false));
            }
        }
        
        function drawBackground() {
            ctx.fillStyle = '#34495e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Grid
            ctx.strokeStyle = 'rgba(255,255,255,0.1)';
            for (let i = 0; i < canvas.width; i += 40) {
                ctx.beginPath();
                ctx.moveTo(i, 0);
                ctx.lineTo(i, canvas.height);
                ctx.stroke();
            }
            for (let i = 0; i < canvas.height; i += 40) {
                ctx.beginPath();
                ctx.moveTo(0, i);
                ctx.lineTo(canvas.width, i);
                ctx.stroke();
            }
            
            // Walls
            walls.forEach(wall => {
                ctx.fillStyle = '#7f8c8d';
                ctx.fillRect(wall.x, wall.y, wall.w, wall.h);
            });
        }
        
        function updateGame() {
            if (!gameRunning || gamePaused) return;
            
            drawBackground();
            
            player.update();
            player.draw();
            
            enemies.forEach(e => { e.update(); e.draw(); });
            
            bullets = bullets.filter(b => 
                b.x > 0 && b.x < canvas.width && 
                b.y > 0 && b.y < canvas.height && 
                !b.checkWallHit()
            );
            bullets.forEach(b => { b.update(); b.draw(); });
            
            // Check bullet collisions
            for (let i = bullets.length - 1; i >= 0; i--) {
                if (bullets[i].isPlayer) {
                    for (let j = enemies.length - 1; j >= 0; j--) {
                        const dx = bullets[i].x - enemies[j].x;
                        const dy = bullets[i].y - enemies[j].y;
                        if (Math.sqrt(dx*dx + dy*dy) < 20) {
                            enemies[j].health -= 15;
                            bullets.splice(i, 1);
                            if (enemies[j].health <= 0) {
                                explosions.push(new Explosion(enemies[j].x, enemies[j].y));
                                enemies.splice(j, 1);
                                score += 100;
                                kills++;
                                document.getElementById('score').textContent = score;
                                document.getElementById('enemies').textContent = kills;
                            }
                            break;
                        }
                    }
                } else {
                    const dx = bullets[i].x - player.x;
                    const dy = bullets[i].y - player.y;
                    if (Math.sqrt(dx*dx + dy*dy) < 20) {
                        player.health -= 10;
                        bullets.splice(i, 1);
                        document.getElementById('health').textContent = player.health;
                        if (player.health <= 0) endGame();
                    }
                }
            }
            
            explosions = explosions.filter(e => !e.isDone());
            explosions.forEach(e => { e.update(); e.draw(); });
            
            if (Math.random() < 0.01) spawnEnemy();
            
            requestAnimationFrame(updateGame);
        }
        
        canvas.addEventListener('mousemove', e => {
            const rect = canvas.getBoundingClientRect();
            mouseX = (e.clientX - rect.left) * (canvas.width / rect.width);
            mouseY = (e.clientY - rect.top) * (canvas.height / rect.height);
        });
        
        canvas.addEventListener('click', () => {
            if (gameRunning && !gamePaused && Date.now() - player.lastShot > player.fireRate) {
                player.shoot();
            }
        });
        
        document.addEventListener('keydown', e => { keys[e.code] = true; });
        document.addEventListener('keyup', e => { keys[e.code] = false; });
        
        function startGame() {
            if (gameRunning) return;
            initWalls();
            player = new Tank(canvas.width/2, canvas.height - 50, true);
            enemies = [];
            bullets = [];
            explosions = [];
            score = 0; kills = 0;
            document.getElementById('score').textContent = '0';
            document.getElementById('health').textContent = '100';
            document.getElementById('enemies').textContent = '0';
            gameRunning = true;
            gamePaused = false;
            updateGame();
        }
        
        function pauseGame() { gamePaused = !gamePaused; if (!gamePaused) updateGame(); }
        
        function endGame() {
            gameRunning = false;
            document.getElementById('finalKills').textContent = kills;
            document.getElementById('gameOver').style.display = 'block';
        }
        
        function restartGame() {
            document.getElementById('gameOver').style.display = 'none';
            startGame();
        }
        
        initWalls();
        drawBackground();
    </script>
</body>
</html>
