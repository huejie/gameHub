<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>åƒç´ ç”»æ¿ - GameHub100</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Arial', sans-serif; background: #2d3436; min-height: 100vh; display: flex; flex-direction: column; align-items: center; color: white; padding: 20px; }
        .header { text-align: center; margin-bottom: 15px; }
        h1 { font-size: 2rem; }
        .tools { display: flex; gap: 10px; margin: 10px 0; flex-wrap: wrap; justify-content: center; }
        .color { width: 30px; height: 30px; border-radius: 5px; cursor: pointer; border: 2px solid transparent; }
        .color.selected { border-color: white; transform: scale(1.2); }
        canvas { border: 2px solid #636e72; border-radius: 5px; cursor: crosshair; }
        .controls { display: flex; gap: 10px; margin-top: 15px; flex-wrap: wrap; justify-content: center; }
        button { padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer; background: #6c5ce7; color: white; font-weight: bold; }
        button:hover { background: #a29bfe; }
        .back-link { position: fixed; top: 15px; left: 15px; color: white; text-decoration: none; }
        .size-control { display: flex; align-items: center; gap: 10px; }
        input[type="range"] { width: 100px; }
    </style>
</head>
<body>
    <a href="../index.html" class="back-link">â† è¿”å›</a>
    <div class="header"><h1>ğŸ¨ åƒç´ ç”»æ¿</h1><p>åˆ›ä½œä½ çš„åƒç´ è‰ºæœ¯ï¼</p></div>
    <div class="tools" id="colors"></div>
    <div class="size-control">
        <span>ç”»ç¬”:</span>
        <input type="range" id="brushSize" min="1" max="5" value="1">
        <span id="sizeDisplay">1</span>
    </div>
    <canvas id="canvas" width="400" height="400"></canvas>
    <div class="controls">
        <button onclick="clearCanvas()">æ¸…ç©º</button>
        <button onclick="saveCanvas()">ä¿å­˜</button>
        <button onclick="fillBucket()">å¡«å……</button>
    </div>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const PIXEL = 10;
        const COLS = canvas.width / PIXEL;
        const ROWS = canvas.height / PIXEL;
        
        const palette = ['#e74c3c', '#e67e22', '#f1c40f', '#2ecc71', '#1abc9c', '#3498db', '#9b59b6', '#34495e', '#ecf0f1', '#2c3e50', '#d35400', '#c0392b', '#16a085', '#2980b9', '#8e44ad', '#27ae60'];
        
        let currentColor = palette[0];
        let brushSize = 1;
        let isDrawing = false;
        let fillMode = false;
        
        // Initialize
        ctx.fillStyle = '#fff';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Draw grid
        ctx.strokeStyle = '#ddd';
        ctx.lineWidth = 0.5;
        for (let i = 0; i <= COLS; i++) {
            ctx.beginPath();
            ctx.moveTo(i * PIXEL, 0);
            ctx.lineTo(i * PIXEL, canvas.height);
            ctx.stroke();
        }
        for (let i = 0; i <= ROWS; i++) {
            ctx.beginPath();
            ctx.moveTo(0, i * PIXEL);
            ctx.lineTo(canvas.width, i * PIXEL);
            ctx.stroke();
        }
        
        // Color palette
        const colorsDiv = document.getElementById('colors');
        palette.forEach(color => {
            const div = document.createElement('div');
            div.className = 'color' + (color === currentColor ? ' selected' : '');
            div.style.background = color;
            div.onclick = () => {
                document.querySelectorAll('.color').forEach(c => c.classList.remove('selected'));
                div.classList.add('selected');
                currentColor = color;
                fillMode = false;
            };
            colorsDiv.appendChild(div);
        });
        
        document.getElementById('brushSize').oninput = (e) => {
            brushSize = parseInt(e.target.value);
            document.getElementById('sizeDisplay').textContent = brushSize;
        };
        
        function draw(x, y) {
            const col = Math.floor(x / PIXEL);
            const row = Math.floor(y / PIXEL);
            
            ctx.fillStyle = currentColor;
            for (let i = -brushSize + 1; i < brushSize; i++) {
                for (let j = -brushSize + 1; j < brushSize; j++) {
                    const c = col + i;
                    const r = row + j;
                    if (c >= 0 && c < COLS && r >= 0 && r < ROWS) {
                        ctx.fillRect(c * PIXEL, r * PIXEL, PIXEL, PIXEL);
                    }
                }
            }
        }
        
        function floodFill(startX, startY) {
            const startCol = Math.floor(startX / PIXEL);
            const startRow = Math.floor(startY / PIXEL);
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const startColor = getPixelColor(imageData, startCol * PIXEL + 5, startRow * PIXEL + 5);
            
            if (colorsMatch(startColor, hexToRgb(currentColor))) return;
            
            const stack = [[startCol, startRow]];
            const visited = new Set();
            
            while (stack.length > 0) {
                const [col, row] = stack.pop();
                const key = `${col},${row}`;
                
                if (visited.has(key) || col < 0 || col >= COLS || row < 0 || row >= ROWS) continue;
                
                const pixelColor = getPixelColor(imageData, col * PIXEL + 5, row * PIXEL + 5);
                if (!colorsMatch(pixelColor, startColor)) continue;
                
                visited.add(key);
                ctx.fillStyle = currentColor;
                ctx.fillRect(col * PIXEL, row * PIXEL, PIXEL, PIXEL);
                
                stack.push([col + 1, row], [col - 1, row], [col, row + 1], [col, row - 1]);
            }
        }
        
        function getPixelColor(data, x, y) {
            const i = (y * data.width + x) * 4;
            return [data.data[i], data.data[i + 1], data.data[i + 2]];
        }
        
        function hexToRgb(hex) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return [r, g, b];
        }
        
        function colorsMatch(c1, c2) {
            return Math.abs(c1[0] - c2[0]) < 10 && Math.abs(c1[1] - c2[1]) < 10 && Math.abs(c1[2] - c2[2]) < 10;
        }
        
        canvas.addEventListener('mousedown', (e) => {
            isDrawing = true;
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * (canvas.width / rect.width);
            const y = (e.clientY - rect.top) * (canvas.height / rect.height);
            
            if (fillMode) {
                floodFill(x, y);
            } else {
                draw(x, y);
            }
        });
        
        canvas.addEventListener('mousemove', (e) => {
            if (!isDrawing || fillMode) return;
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * (canvas.width / rect.width);
            const y = (e.clientY - rect.top) * (canvas.height / rect.height);
            draw(x, y);
        });
        
        canvas.addEventListener('mouseup', () => isDrawing = false);
        canvas.addEventListener('mouseleave', () => isDrawing = false);
        
        function clearCanvas() {
            ctx.fillStyle = '#fff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
        
        function saveCanvas() {
            const link = document.createElement('a');
            link.download = 'pixel-art.png';
            link.href = canvas.toDataURL();
            link.click();
        }
        
        function fillBucket() {
            fillMode = !fillMode;
            alert(fillMode ? 'å¡«å……æ¨¡å¼å·²å¼€å¯ï¼Œç‚¹å‡»è¦å¡«å……çš„åŒºåŸŸ' : 'å¡«å……æ¨¡å¼å·²å…³é—­');
        }
    </script>
</body>
</html>