<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ê≥°Ê≥°Èæô - GameHub100</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Arial', sans-serif; background: linear-gradient(135deg, #3498db 0%, #2980b9 100%); min-height: 100vh; display: flex; flex-direction: column; align-items: center; color: white; padding: 20px; }
        .header { text-align: center; margin-bottom: 15px; }
        h1 { font-size: 2rem; }
        canvas { border: 3px solid #fff; border-radius: 10px; cursor: crosshair; }
        .stats { display: flex; justify-content: center; gap: 30px; margin: 15px 0; }
        .stat-value { font-size: 1.5rem; font-weight: bold; }
        .controls { text-align: center; }
        button { padding: 12px 25px; border: none; border-radius: 8px; cursor: pointer; background: #e74c3c; color: white; font-weight: bold; margin: 5px; }
        .back-link { position: fixed; top: 15px; left: 15px; color: white; text-decoration: none; }
    </style>
</head>
<body>
    <a href="../../index.html" class="back-link">‚Üê ËøîÂõû</a>
    <div class="header"><h1>ü´ß Ê≥°Ê≥°Èæô</h1><p>ÁûÑÂáÜÂèëÂ∞ÑÔºå‰∏â‰∏™Áõ∏ÂêåÊ∂àÈô§</p></div>
    <div class="stats">
        <div class="stat"><div class="stat-value" id="score">0</div><div>ÂæóÂàÜ</div></div>
    </div>
    <canvas id="canvas" width="400" height="500"></canvas>
    <div class="controls"><button onclick="newGame()">Êñ∞Ê∏∏Êàè</button></div>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const colors = ['#e74c3c', '#3498db', '#2ecc71', '#f1c40f', '#9b59b6'];
        const R = 18, COLS = 11, ROWS = 12;
        
        let grid = [], shooter, score = 0, nextColor;
        
        function newGame() {
            score = 0;
            document.getElementById('score').textContent = '0';
            grid = [];
            for (let r = 0; r < 5; r++) {
                grid[r] = [];
                const cols = r % 2 === 0 ? COLS : COLS - 1;
                for (let c = 0; c < cols; c++) {
                    grid[r][c] = Math.floor(Math.random() * colors.length);
                }
            }
            for (let r = 5; r < ROWS; r++) grid[r] = [];
            
            shooter = {x: canvas.width / 2, y: canvas.height - 40, angle: -Math.PI / 2, bubble: null};
            nextColor = Math.floor(Math.random() * colors.length);
            render();
        }
        
        function getPos(r, c) {
            const x = c * R * 2 + R + (r % 2 === 1 ? R : 0);
            const y = r * R * 1.73 + R;
            return {x, y};
        }
        
        function render() {
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw bubbles
            for (let r = 0; r < ROWS; r++) {
                const cols = grid[r] ? grid[r].length : 0;
                for (let c = 0; c < cols; c++) {
                    if (grid[r][c] !== undefined && grid[r][c] !== -1) {
                        const pos = getPos(r, c);
                        ctx.fillStyle = colors[grid[r][c]];
                        ctx.beginPath();
                        ctx.arc(pos.x, pos.y, R - 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }
            
            // Draw shooter
            ctx.fillStyle = colors[nextColor];
            ctx.beginPath();
            ctx.arc(shooter.x, shooter.y, R, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw aim line
            ctx.strokeStyle = 'rgba(255,255,255,0.3)';
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(shooter.x, shooter.y);
            ctx.lineTo(shooter.x + Math.cos(shooter.angle) * 200, shooter.y + Math.sin(shooter.angle) * 200);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Draw flying bubble
            if (shooter.bubble) {
                ctx.fillStyle = colors[shooter.bubble.color];
                ctx.beginPath();
                ctx.arc(shooter.bubble.x, shooter.bubble.y, R, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        canvas.addEventListener('mousemove', e => {
            const rect = canvas.getBoundingClientRect();
            const mx = (e.clientX - rect.left) * (canvas.width / rect.width);
            const my = (e.clientY - rect.top) * (canvas.height / rect.height);
            shooter.angle = Math.atan2(my - shooter.y, mx - shooter.x);
            shooter.angle = Math.max(-Math.PI + 0.1, Math.min(-0.1, shooter.angle));
            if (!shooter.bubble) render();
        });
        
        canvas.addEventListener('click', () => {
            if (!shooter.bubble) {
                shooter.bubble = {x: shooter.x, y: shooter.y, vx: Math.cos(shooter.angle) * 10, vy: Math.sin(shooter.angle) * 10, color: nextColor};
                nextColor = Math.floor(Math.random() * colors.length);
            }
        });
        
        function update() {
            if (shooter.bubble) {
                shooter.bubble.x += shooter.bubble.vx;
                shooter.bubble.y += shooter.bubble.vy;
                
                // Wall bounce
                if (shooter.bubble.x < R || shooter.bubble.x > canvas.width - R) {
                    shooter.bubble.vx *= -1;
                }
                
                // Top collision
                if (shooter.bubble.y < R) {
                    attachBubble();
                }
                
                // Bubble collision
                for (let r = 0; r < ROWS; r++) {
                    const cols = grid[r] ? grid[r].length : 0;
                    for (let c = 0; c < cols; c++) {
                        if (grid[r][c] !== undefined && grid[r][c] !== -1) {
                            const pos = getPos(r, c);
                            const dist = Math.sqrt((shooter.bubble.x - pos.x) ** 2 + (shooter.bubble.y - pos.y) ** 2);
                            if (dist < R * 2) {
                                attachBubble();
                                break;
                            }
                        }
                    }
                }
            }
            render();
            requestAnimationFrame(update);
        }
        
        function attachBubble() {
            // Find nearest grid position
            let minDist = Infinity, bestR = 0, bestC = 0;
            for (let r = 0; r < ROWS; r++) {
                const maxC = r % 2 === 0 ? COLS : COLS - 1;
                if (!grid[r]) grid[r] = [];
                for (let c = 0; c < maxC; c++) {
                    if (grid[r][c] === undefined || grid[r][c] === -1) {
                        const pos = getPos(r, c);
                        const dist = Math.sqrt((shooter.bubble.x - pos.x) ** 2 + (shooter.bubble.y - pos.y) ** 2);
                        if (dist < minDist) {
                            minDist = dist;
                            bestR = r;
                            bestC = c;
                        }
                    }
                }
            }
            grid[bestR][bestC] = shooter.bubble.color;
            shooter.bubble = null;
            
            // Check matches
            checkMatches(bestR, bestC);
        }
        
        function checkMatches(r, c) {
            const color = grid[r][c];
            const visited = new Set();
            const matches = [];
            
            function dfs(rr, cc) {
                const key = rr + ',' + cc;
                if (visited.has(key)) return;
                if (grid[rr] === undefined || grid[rr][cc] !== color) return;
                visited.add(key);
                matches.push([rr, cc]);
                
                const neighbors = rr % 2 === 0 
                    ? [[rr-1,cc-1],[rr-1,cc],[rr,cc-1],[rr,cc+1],[rr+1,cc-1],[rr+1,cc]]
                    : [[rr-1,cc],[rr-1,cc+1],[rr,cc-1],[rr,cc+1],[rr+1,cc],[rr+1,cc+1]];
                
                neighbors.forEach(([nr, nc]) => {
                    if (nr >= 0 && nr < ROWS && nc >= 0) dfs(nr, nc);
                });
            }
            
            dfs(r, c);
            
            if (matches.length >= 3) {
                matches.forEach(([rr, cc]) => {
                    grid[rr][cc] = -1;
                });
                score += matches.length * 10;
                document.getElementById('score').textContent = score;
            }
        }
        
        newGame();
        update();
    </script>
</body>
</html>